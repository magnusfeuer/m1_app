//
// All rights reserved. Reproduction, modification, use or disclosure
// to third parties without express authority is forbidden.
// Copyright Magden LLC, California, USA, 2004, 2005, 2006, 2007, 2008.
//

//
// High level logic for the Magden AD device plugin.
//
library ADDeviceLib {
    //
    // An ADDevice with a number of AD channels.
    //
    type ADDevice: MagdenADDevice {
	type ADChannel {
	    int index; // Index into MagdenADDevice.channelss
	    Psigned sensorTypeDB;
	    Psigned engChannelDB;
	    string name;
	    event int sensor;
	    event int engChannel;
	    event int usage;
	    ScalarInterpolator map; // Copied from sensorProfiles.
	    ADDevice owner;
	    int currentChannel = -1; // Used to keep track of supported
	    int supportedSensorTypes[]; // contains indexes into .ADLib.sensorTypes[]
	    
	    // Enable or disable the sampling from the given channel
	    
	    script usage when usage == 0 {
		printf("ADChannel[%d]: Usage [%d]. Unsubscribe\n", index, usage);
		owner.channels[index].sampleInterval = 0;
	    }

	    script usage when usage != 0 {
		printf("ADChanne[%d]: Usage [%d].\n", index, usage);
		owner.channels[index].sampleInterval = .ADLib.sensorTypes[sensor].sampleInterval;
	    }

	    //
	    // The sensor or engine channel we use has been updated. Setup the engine channel
	    //
	    script sensor || engChannel when sensor != -1 && engChannel != -1{
		printf("ADChannel[%d]: sensor[%d] engChannel[%d]\n", index, sensor, engChannel);
		usage <- .EngineBaseLib.engine.channels[engChannel].usage;	
		*usage = .EngineBaseLib.engine.channels[engChannel].usage; // Trigger usage script.
	        map := .ADLib.sensorTypes[sensor].map;
		map.fraction <- @float(owner.channels[index].value);
		
		.EngineBaseLib.engine.channels[engChannel].value <- map.value;;
		.EngineBaseLib.engine.channels[engChannel].value = map.value;

		// Disable support of old channel
		if (currentChannel != -1) {
		    printf("ADChannel[%d/%d]: Disabling support for [%s]\n", index, currentChannel, .EngineBaseLib.engine.channels[currentChannel].descriptor.name);
		    .EngineBaseLib.engine.channels[currentChannel].supported = false;
		}
		// Enable support of new channel.
		printf("ADChannel[%d]: Enabling support for [%s]\n", index,  .EngineBaseLib.engine.channels[engChannel].descriptor.name);
		.EngineBaseLib.engine.channels[engChannel].supported = true;
		currentChannel = engChannel;
	    }

	    script ADChannel {
		currentChannel = -1; 
		// Which type of sensor do we use. Index into .ADLib.sensorTypes
		sensorTypeDB = @Psigned { key = sprintf("core.ad.%d.sensor", index), value = -1 };

		// Which engine channel is this AD channel tied to. Index into .EngineBaseLib.engine.channels
		engChannelDB = @Psigned { key = sprintf("core.ad.%d.eng_chan", index), value = -1 };

		// Subscribe to if the sensor we use has been updated.
		sensor <- sensorTypeDB.value;
		engChannel <- engChannelDB.value;
		*sensor = sensorTypeDB.value; // Trigger sensor script
	    }
	};

	ADChannel sensorChannels[];
	    
	script ADDevice {
	    int i;

	    // Setup sensors based.
	    foreach i in [0:size(channels) - 1] {
		sensorChannels[i] = @ADChannel { name = sprintf("channel %d", i), index = i, owner = this, supportedSensorTypes = { .ADLib.unused } }; 
 	    }
	}
    };

    ADDevice adDevice = @ADDevice { port = "/dev/ttyUSB1", portSpeed=115200 };
}
